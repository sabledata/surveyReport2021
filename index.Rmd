---
title: |
  "Summary of the annual 2021 Sablefish (*Anoplopoma fimbria*) trap survey, October 6 - November 21, 2021"
french_title: Titre ici (*Nom latin de l'espèce*)
year: 2023
report_number: nnn
author: |
  Lisa C. Lacko, 
  Schon M. Acheson, and
  Kendra R. Holt
author_list: "Lacko, L.C., Acheson, S.M. and Holt, K.R."
region: Pacific Region
french_region: Région du Pacifique
isbn: ""
address: |
  ^1^Pacific Biological Station\
     Fisheries and Oceans Canada, 3190 Hammond Bay Road\
     Nanaimo, British Columbia, V9T 6N7, Canada\
french_address: |
  ^1^Station biologique du Pacifique\
     Pêches et Océans Canada, 3190 Hammond Bay Road\
     Nanaimo, Colombie-Britannique, V9T 6N7, Canada\
phone: "(250) 756-7000"
author_footnote: "Email: Lisa.Lacko@dfo-mpo.gc.ca | telephone: (778) 268-3236"
abstract: |
  This document describes sampling activities and summarizes results from the 2021 British Columbia Sablefish research and assessment survey.  The survey was comprised of stratified random sets (StRS) at five depth-stratified areas and standardized sets at one traditional inlet locality. Four sets were dedicated to bottom contact research with 3 deep-water autonomous cameras mounted on a 60 trap string. Biological sampling was conducted for Sablefish and incidentally captured species such as rockfishes and Lingcod.  Sablefish were randomly sampled from every third trap on all sets, up to a maximum sample count of 50. The tag and release study conducted annually since 1991 was continued in 2021.  
  
  A total of 41,020 Sablefish were caught on StRS sets in 2021, of which 3,865 were used for biological samples and 8,013 were tagged and released.  Due to weather conditions, 77 out of 111 planned StRS blocks and one out of four mainland inlets were surveyed.  Survey CPUE are presented in relation to previous years to describe trends over time.  In the most recent 2 years, survey data from stratified random sets show a slight increasing trend in CPUE.  At the 2021 StRS sites, the stratified mean survey abundance was 36 kg/trap, up 3% from 2020 and down -6% from the 2019-2020 average.
french_abstract: |
  Le présent document décrit les activités d’échantillonnage réalisées dans le cadre du relevé d’évaluation et de recherche de 2021 sur la morue charbonnière mené en Colombie-Britannique, et résume les résultats connexes.  Ce relevé comprenait des traits ayant fait l’objet d’un échantillonnage aléatoire stratifié qui ont été effectués dans cinq zones stratifiées en fonction de la profondeur et des traits normalisés réalisés dans un site traditionnel des bras de mer. Quatre traits ont été consacrés à la recherche de fond avec 3 caméras autonomes en eau profonde montées sur une ligne de 60 pièges. On a effectué un échantillonnage biologique pour la morue charbonnière et les espèces capturées accidentellement, comme les sébastes et les morues-lingues.  On a échantillonné les morues charbonnières capturées de façon aléatoire à partir du troisième casier de chaque trait, jusqu’à l’atteinte d’une taille d’échantillon maximale de 50 individus. L’étude de marquage et de remise à l’eau menée annuellement depuis 1991 s’est poursuivie en 2021.    
  
  Au total, 41 020 morues charbonnières ont été capturées en 2021 au moyen de traits ayant fait l’objet d’un échantillonnage aléatoire stratifié. Parmi celles-ci, 3 865 ont été utilisées pour le prélèvement d’échantillons biologiques et 8 013 ont été marquées, puis remises à l’eau. En raison des conditions météorologiques, 77 des 111 des blocs d’échantillonnage aléatoire stratifié et un des quatre bras de mer continentaux ont fait l’objet d’un échantillonnage. Les CPUE des relevés sont présentées en rapport avec les années précédentes afin de décrire les tendances au fil du temps. Au cours des deux dernières années, les données de relevé provenant des ensembles aléatoires stratifiés montrent une légère tendance à l’augmentation des CPUE. Aux sites où ces traits ont été effectués en 2021, l’abondance moyenne stratifiée du relevé était de 36 kg/casier, soit une augmentation de 3 % par rapport à 2020 et une diminution de 6 % par rapport à la moyenne de 2019-2020.

output:
 csasdown::techreport_pdf:
   french: false
   # copy_sty is a toggle to copy the style file from the csasdown package every time you compile
   # the document. If false, any changes you have made to the style file in your project
   # will remain between compilations. If true, your changes will be lost when you compile
   copy_sty: true
   # line_nums is a toggle to show line numbers on the left side of the page. 
   line_nums: true
   # line_nums_mod represents showing every Nth line if line_nums is true
   line_nums_mod: 1
   # lot_lof is a toggle to show/not show the lists of tables and figures at the
   # beginning of the document
   lot_lof: false
   # draft_watermark is a toggle to show/not show a DRAFT watermark across every page
   draft_watermark: false
   # highlight is the theme to use for code output. Must be one of the list given by:
   # pandoc --list-highlight-styles
   # which are:
   # pygments, tango, espresso, zenburn, kate, monochrome, breezedark, haddock
   # or the name of a custom *.latex file which is most easily made by copying one from 
   # the csasdown library 'themes' directory, this directory on your machine:
   # file.path(.libPaths(), "csasdown", "themes")
   # to your working directory (the one containing index.Rmd)
   # To change the foreground text color, change the RGB value in the line containing
   # 'DefineVerbatimEnvironment'
   # To change background color, change the RGB values in the line containing 'shadecolor'
   highlight: tango
type:
  techreport
# ------------
# End of options to set
knit: (function(input, ...) {
       csasdown::render('_bookdown.yml')
      })
site: bookdown::bookdown_site
link-citations: true
bibliography: bib/refs.bib
# Any extra LaTeX code for the header:
header-includes:
 - \usepackage{float}
---

```{r setup, echo=FALSE, cache=FALSE, message=FALSE, results='hide', warning=FALSE}
library(knitr)
if (is_latex_output()) {
  knitr_figs_dir <- "knitr-figs-pdf/"
  knitr_cache_dir <- "knitr-cache-pdf/"
  fig_out_type <- "png"
} else {
  knitr_figs_dir <- "knitr-figs-docx/"
  knitr_cache_dir <- "knitr-cache-docx/"
  fig_out_type <- "png"
}
fig_asp <- 0.618
fig_width <- 9
fig_out_width <- "6in"
fig_dpi <- 180
fig_align <- "center"
fig_pos <- "htb"
opts_chunk$set(
  collapse = TRUE,
  warning = FALSE,
  message = FALSE,
  comment = "#>",
  fig.path = knitr_figs_dir,
  cache.path = knitr_cache_dir,
  fig.asp = fig_asp,
  fig.width = fig_width,
  out.width = fig_out_width,
  echo = FALSE,
  #  autodep = TRUE,
  #  cache = TRUE,
  cache.comments = FALSE,
  dev = fig_out_type,
  dpi = fig_dpi,
  fig.align = fig_align,
  fig.pos = fig_pos
)
```

```{r load-libraries, cache=FALSE}

yr       <-  2021
basepath <- 'c:/github/surveyReport2021/'
path     <- 'c:/github/surveyReport2021/standaloneData/'


# add other packages here:
library(dplyr)
library(ggplot2)
library(readr)
library(tibble)
library(rosettafish)
library(csasdown)


# unique to report
library(RODBC)
library(kableExtra) # produces html tables with scrollbars, etc
library(cowplot)


#  ----   G L O B A L --- F U N C T I O N S ---------------------------------

  GetSQLData <- function(strSQL,strDbName) {    # connect to SQL Server
         cnn <- odbcDriverConnect(paste("Driver={SQL Server};Server=DFBCV9TWVASP001;", 
                                         "Database=",
                                          strDbName,";
                                          Trusted_Connection=Yes",
                                          sep=""))
            dat <- sqlQuery(cnn, strSQL)
            odbcClose(cnn)
            return(dat) 
                                            }
  
  panLab <- function( x, y, txt, ... ) { # Allows text to be placed at 0<x<1, 0<y<1)
            usr <- par( "usr" )
            par( usr=c(0,1,0,1) )
            text( x, y, txt, ... )
            par( usr=usr )
            #return( NULL )
            }
  
  cleanf <- function(x){                            # function to remove duplicates
            oldx <- c(FALSE, x[-1]==x[-length(x)])  # is the value equal to the previous
            res <- x
            res[oldx] <- NA
            return(res)
            } 
  
  simpleCap <- function(x) {  # add capital first letter to each word
            s <- strsplit(x, " ")[[1]]
            paste(toupper(substring(s, 1,1)), substring(s, 2),
            sep="", 
            collapse=" ")
            }
  
  firstup <- function(x) {   # add capital first letter to first word
            substr(x, 1, 1) <- toupper(substr(x, 1, 1))
            x
  }
  
  format_cells <- function(df, rows ,cols, value = c("italics", "bold", "strikethrough")){

            # select the correct markup
            map    <- setNames(c("*", "**", "~~"), c("italics", "bold", "strikethrough"))
            markup <- map[value]  
            
            for (r in rows){
                  for(c in cols){
                      df[[c]] <- as.character( df[[c]])  # -- make sure values are not factors
                      df[r, c] <- paste0(markup, df[r, c], markup)  # -- Update formatting
                                }
                           }
                     return(df)
            }
            
  fig_label <- function(text, region="figure", pos="topleft", cex=NULL, ...) {
           
            region <- match.arg(region, c("figure", "plot", "device"))
            pos <- match.arg(pos, c("topleft", "top", "topright", 
                                    "left", "center", "right", 
                                    "bottomleft", "bottom", "bottomright"))
           
            if(region %in% c("figure", "device")) {
              ds <- dev.size("in")
              # xy coordinates of device corners in user coordinates
              x <- grconvertX(c(0, ds[1]), from="in", to="user")
              y <- grconvertY(c(0, ds[2]), from="in", to="user")
           
              # fragment of the device we use to plot
              if(region == "figure") {
                # account for the fragment of the device that 
                # the figure is using
                fig <- par("fig")
                dx <- (x[2] - x[1])
                dy <- (y[2] - y[1])
                x <- x[1] + dx * fig[1:2]
                y <- y[1] + dy * fig[3:4]
              } 
            }
           
            # much simpler if in plotting region
            if(region == "plot") {
              u <- par("usr")
              x <- u[1:2]
              y <- u[3:4]
            }
           
            sw <- strwidth(text, cex=cex) * 60/100
            sh <- strheight(text, cex=cex) * 60/100
           
            x1 <- switch(pos,
              topleft     =x[1] + sw, 
              left        =x[1] + sw,
              bottomleft  =x[1] + sw,
              top         =(x[1] + x[2])/2,
              center      =(x[1] + x[2])/2,
              bottom      =(x[1] + x[2])/2,
              topright    =x[2] - sw,
              right       =x[2] - sw,
              bottomright =x[2] - sw)
           
            y1 <- switch(pos,
              topleft     =y[2] - sh,
              top         =y[2] - sh,
              topright    =y[2] - sh,
              left        =(y[1] + y[2])/2,
              center      =(y[1] + y[2])/2,
              right       =(y[1] + y[2])/2,
              bottomleft  =y[1] + sh,
              bottom      =y[1] + sh,
              bottomright =y[1] + sh)
           
            old.par <- par(xpd=NA)
            on.exit(par(old.par))
           
            text(x1, y1, text, cex=cex, ...)
            return(invisible(c(x,y)))
            }
  
    inline_hook <- function(x) {  # -- for inline text where numbers are larger 
      if (is.numeric(x)) {
            format(x, digits = 2)
                         } else x
      }
    knitr::knit_hooks$set(inline = inline_hook)

```

```{r SurveyDetails, echo=FALSE}  
   # -- INTRODUCTION DETAILS --

   report      <-  'exec Report_CreateTables'
   rep.data    <-  GetSQLData(report,"Sablefish")
   details <- "select * from GFSH_"
   details     <- paste("select VESSEL_NAME as Vessel, CAPTAIN, ",
                        "left(CONVERT(varchar, START_DATE, 100), 7) + ' - ' ",
                        "+ left(CONVERT(varchar, END_DATE, 100), 7) AS [Trip Dates], ",
                        "COUNT([SET]) AS [Count of Sets], ",
                        "DATEDIFF(DAY, START_DATE, END_DATE) + 1 as days, ",
                        "START_DATE, END_DATE ",   #taken from survey notes
                        "from  dbo.GFBIO_RESEARCH_TRIPS ",
                        "where year IN( ", yr ,") ", 
                        "group by ",
                        "VESSEL_NAME, CAPTAIN,  ",
                        "left(CONVERT(varchar, START_DATE, 100),7) + ' - ' + ",
                        "left(CONVERT(varchar, END_DATE, 100),7), ",
                        "DATEDIFF(DAY, START_DATE, END_DATE), START_DATE, END_DATE",
                         sep="")
   #sd     <- GetSQLData(details,"Sablefish")  # -- survey details
   #write.table( sd, file = paste(path,"index01.csv",sep=''),row.names=FALSE, na="",col.names=TRUE,  sep=",")
   sd     <- read.csv(paste(path,'index01.csv',sep=''), header=T)
   
   boat        <- simpleCap(tolower(sd[1,1]))      # -- vessel name 
   captain     <- "Albert (Deacon) Melnychuk"      # -- captain name -- override name from db for 2021
   dates       <-   sd[1,3]                          # -- survey start and end dates 
   setcnt      <-   sd[1,4]                          # -- survey set count 
   days        <-   sd[1,5]                          # -- days survey total to match paper docs
   legone      <-   sd[1,6]    # demo
   legtwo      <-   sd[1,7]   

   avgC        <- paste("select round(AVG(TOTAL), 0) AS YrAvg ",
                        "from   dbo.TableA2_Annual_sablefish_Landing_in_Can_waters_2 ",
                        "where  (year <= ", yr, ") and (year >= ",yr - 9,")", sep="")
   #avgTen      <- GetSQLData(avgC,"Sablefish")    # -- average catch last 10 years 
   #write.table(avgTen, file = paste(path,"index02.csv",sep=''),row.names=FALSE, na="",col.names=TRUE,  sep=",")
   avgTen      <- read.csv(paste(path,'index02.csv', sep=''),header=T)
   
   tp          <- paste("select round(TRAP / TOTAL * 100, 0) AS TrapPer ",
                        "from dbo.TableA2_Annual_sablefish_Landing_in_Can_waters_2 ",  
                        "where  (year = ", yr, ")  group by round(TRAP / TOTAL * 100, 0), TOTAL", sep="")
   trapP       <- GetSQLData(tp,"Sablefish")        # -- trap gear catch ratio
   #write.table(trapP, file = paste(path,"index03.csv",sep=''),row.names=FALSE, na="",col.names=TRUE,  sep=",")   
   #trapP      <-   read.csv(paste(path,'index03.csv', sep=''),header=T)
   
   lp          <- paste( "select  round(LONGLINE / TOTAL * 100, 0) AS LonglinePer from ",  
                         "dbo.TableA2_Annual_sablefish_Landing_in_Can_waters_2  ",
                         "where  (year = ", yr, ") group by round(LONGLINE / TOTAL * 100, 0), TOTAL", sep="")
   LonglineP   <- GetSQLData(lp,"Sablefish")        # -- longline gear catch ratio
   #write.table(LonglineP, file = paste(path,"index04.csv",sep=''),row.names=FALSE, na="",col.names=TRUE,  sep=",")    
   #LonglineP   <- read.csv(paste(path,'index04.csv', sep=''), header=T)

   # -- F I G U R E   C A P T I O N S  function ------------------------------------------------
   figure_nums <-  captioner::captioner(prefix = "Figure")
   fg.ref      <-  function(x) {    # another method on how to number figures
                                     stringr::str_extract(figure_nums(x), "[^.]*")}

```


